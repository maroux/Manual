/*---------------------Base.go----------------------*/
// WARNING: Do not modify. This file is machine-generated by manual.

package models

// Base is machine-generated.
//
// The base object.
type Base interface {
	// The type of object.
	GetDiscriminatorType() (string, error)

	GetTestItems() ([]interface{}, error)
}

/*---------------------BaseChild.go----------------------*/
// WARNING: Do not modify. This file is machine-generated by manual.

package models

// BaseChild is machine-generated.
//
// The child object.
//
// BaseChild conforms to:
// - Base
type BaseChild interface {
	// The type of object.
	GetDiscriminatorType() (string, error)

	// An object to be referenced.
	GetReference() (Reference, error)

	GetTestItems() ([]Reference, error)
}

/*---------------------BaseChildChild.go----------------------*/
// WARNING: Do not modify. This file is machine-generated by manual.

package models

import (
	"fmt"
)

// BaseChildChild is machine-generated.
//
// The child child object.
//
// BaseChildChild conforms to:
// - BaseChild
type BaseChildChild struct {
	Bar string `json:"bar"`

	// The type of object.
	DiscriminatorType BaseChildChildDiscriminatorType `json:"discriminator-type"`

	ObjectID string `json:"object_id"`

	// An object to be referenced.
	Reference Reference `json:"reference"`

	SomeObject interface{} `json:"some_object"`

	TestItems []Reference `json:"test-items"`
}

// BaseChildChild's conformance to BaseChild is machine-generated.

// GetDiscriminatorType is machine-generated.
//
// Gets BaseChildChild's DiscriminatorType property.
func (o BaseChildChild) GetDiscriminatorType() (string, error) {
	return string(o.DiscriminatorType), nil
}

// GetReference is machine-generated.
//
// Gets BaseChildChild's Reference property.
func (o BaseChildChild) GetReference() (Reference, error) {
	return o.Reference, nil
}

// GetTestItems is machine-generated.
//
// Gets BaseChildChild's TestItems as BaseChild's property type.
func (o BaseChildChild) GetTestItems() ([]Reference, error) {
	items := make([]Reference, len(o.TestItems))
	for _, item := range o.TestItems {
		items = append(items, item)
	}
	return items, nil
}

type BaseChildChildDiscriminatorType string

const BaseChildChildDiscriminatorTypeValue = "Base_Child_Child"

func (o BaseChildChildDiscriminatorType) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%+q", BaseChildChildDiscriminatorTypeValue)), nil
}

/*---------------------Enumeration.go----------------------*/
// WARNING: Do not modify. This file is machine-generated by manual.

package models

import (
	"fmt"
)

type Enumeration int

const (
		ValueOneEnumValue Enumeration = iota
		ValueTwoEnumValue
		ValueThreeEnumValue
)

func (e Enumeration) String() (string, error) {
	switch e {
		case ValueOneEnumValue:
			return "value-one", nil
		case ValueTwoEnumValue:
			return "value-two", nil
		case ValueThreeEnumValue:
			return "value-three", nil
		default:
			return "", fmt.Errorf("Bad Enumeration value %v.", e)
	}
}

func (e Enumeration) MarshalJSON() ([]byte, error) {
	str, err := e.String()
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("%+q", str)), nil
}

/*---------------------JSONTypes.go----------------------*/
// WARNING: Do not modify. This file is machine-generated by manual.

package models

import (
	"fmt"
	"net/url"
	"strconv"
	"strings"
	"time"
)

type JSONDate time.Time

func (o JSONDate) MarshalJSON() ([]byte, error) {
	t := time.Time(o).Format("2006-01-02")
	return []byte(fmt.Sprintf("%+q", t)), nil
}

func (o *JSONDate) UnmarshalJSON(bytes []byte) error {
	t, err := time.Parse(`"2006-01-02"`, string(bytes))
	if err != nil {
		return err
	}
	*o = JSONDate(t)
	return nil
}

type JSONDateTime time.Time

func (o JSONDateTime) MarshalJSON() ([]byte, error) {
	t := time.Time(o).Format(time.RFC3339Nano)
	return []byte(fmt.Sprintf("%+q", t)), nil
}

func (o *JSONDateTime) UnmarshalJSON(bytes []byte) error {
	t, err := time.Parse(fmt.Sprintf("%+q", time.RFC3339Nano), string(bytes))
	if err != nil {
		return err
	}
	*o = JSONDateTime(t)
	return nil
}

type JSONWeek time.Time

func FormatISO8601Week(t time.Time) string {
	year, week := time.Time(t).ISOWeek()
	return fmt.Sprintf("%04dW%02d", year, week)
}

func ParseISO8601Week(str string) (*time.Time, error) {
	// Must be 7 characters long to match "0001W01" format
	if len(str) != 7 {
		return nil, fmt.Errorf("expected week string %+q to be 7 bytes, but got %d", str, len(str))
	}
	components := strings.Split(str, "W")
	if len(components) != 2 {
		return nil, fmt.Errorf("week string %+q could not be parsed", str)
	}
	year, err := strconv.Atoi(components[0])
	if err != nil {
		return nil, fmt.Errorf("year could not be parsed from week string %+q", str)
	}
	week, err := strconv.Atoi(components[1])
	if err != nil {
		return nil, fmt.Errorf("week could not be parsed from week string %+q", str)
	}
	day := 1
	date := time.Date(year, 1, day, 0, 0, 0, 0, time.UTC)
	dYear, dWeek := date.ISOWeek()
	// Since this could be a week in the year previous, increment the day until we get to the desired week year
	for dYear != year && dWeek > 1 {
		day++
		date = time.Date(year, 1, day, 0, 0, 0, 0, time.UTC)
		dYear, dWeek = date.ISOWeek()
	}
	// Find monday of that week
	for date.Weekday() > 1 {
		day--
		date = time.Date(year, 1, day, 0, 0, 0, 0, time.UTC)
	}
	// Get the first day of the provided week
	date = date.AddDate(0, 0, (week-1)*7)
	for date.Year() > year {
		date = date.AddDate(0, 0, -7)
	}
	return &date, nil
}

func (o JSONWeek) MarshalJSON() ([]byte, error) {
	str := FormatISO8601Week(time.Time(o))
	return []byte(fmt.Sprintf("%+q", str)), nil
}

func (o *JSONWeek) UnmarshalJSON(bytes []byte) error {
	str, err := strconv.Unquote(string(bytes))
	if err != nil {
		return err
	}
	date, err := ParseISO8601Week(str)
	if err != nil {
		return err
	}
	*o = JSONWeek(*date)
	return nil
}

type JSONURL url.URL

func (o JSONURL) MarshalJSON() ([]byte, error) {
	u := url.URL(o)
	str := fmt.Sprintf("%+q", u.String())
	return []byte(str), nil
}

func (o *JSONURL) UnmarshalJSON(bytes []byte) error {
	s, err := strconv.Unquote(string(bytes))
	if err != nil {
		return err
	}
	u, err := url.Parse(s)
	if err != nil {
		return err
	}
	*o = JSONURL(*u)
	return nil
}

/*---------------------Reference.go----------------------*/
// WARNING: Do not modify. This file is machine-generated by manual.

package models

import (
	"fmt"
)

// Reference is machine-generated.
//
// An object to be referenced.
type Reference struct {
	Enumeration Enumeration `json:"enumeration"`

	InLineEnum ReferenceInLineEnum `json:"in-line-enum"`
}

type ReferenceInLineEnum int

const (
		SingleValueEnumValue ReferenceInLineEnum = iota
)

func (e ReferenceInLineEnum) String() (string, error) {
	switch e {
		case SingleValueEnumValue:
			return "single-value", nil
		default:
			return "", fmt.Errorf("Bad ReferenceInLineEnum value %v.", e)
	}
}

func (e ReferenceInLineEnum) MarshalJSON() ([]byte, error) {
	str, err := e.String()
	if err != nil {
		return nil, err
	}
	return []byte(fmt.Sprintf("%+q", str)), nil
}
